/**
 * \file resource-locker.libjsonnet
 * \brief methods to create resource-locker-operator resource and patch objects
 */

local kap = import 'lib/kapitan.libjsonnet';
local kube = import 'lib/kube.libjsonnet';
local com = import 'lib/commodore.libjsonnet';
local inv = kap.inventory();
local resource_locker_params = inv.parameters.resource_locker;
local namespace = resource_locker_params.namespace;

local resourcelocker(name, sa) =
  kube._Object('redhatcop.redhat.io/v1alpha1', 'ResourceLocker', name) {
    metadata+: {
      namespace: namespace,
    },
    spec: {
      serviceAccountRef: {
        name: sa,
      },
    },
  };

// obj can be an arbitrary, valid Kubernetes object manifest
local resource(name, sa, obj) =
  resourcelocker(name, sa) {
    spec+: {
      resources: [{
        excludedPaths: [
          ".metadata",
          ".status",
          ".spec.replicas",
        ],
        object: obj,
      }],
    },
  };

local patch(name, sa, targetobjref, patchtemplate, patchtype="application/strategic-merge-patch+json") =
  resourcelocker(name, sa) {
    spec+: {
      patches:[{
        targetObjectRef: targetobjref,
        patchTemplate: std.manifestYamlDoc(patchtemplate),
        patchType: patchtype,
      }]
    }
  };

local clusterRoleName(name) =
  local prefix = namespace + '-';
  local suffix = '-manager';
  local maxLength = 63 - std.length(prefix) - std.length(suffix);
  local nameLength = std.length(name);
  local start = nameLength - std.min(maxLength, std.length(name));
  prefix + std.substr(name, start, nameLength) + suffix;

local rbac_objs(objdata, verbs=["create", "get", "update", "patch"]) =
  local dest_ns = objdata.namespace;
  local name = objdata.name;
  // Create sa if not provided
  local saname = name+"-manager";
  local serviceaccount = kube.ServiceAccount(saname) {
    metadata+: {
      namespace: namespace,
    },
  };
  // Create cluster role to get/list/watch resource kind
  local rolename = clusterRoleName(name);
  local resource = std.asciiLower(objdata.kind)+"s";
  local clusterrole_extra_verbs = if dest_ns == null then verbs else [];
  local clusterrole = kube.ClusterRole(rolename) {
    rules+: [{
      apiGroups: [objdata.apigroup],
      resources: [resource],
      verbs: std.setUnion(["list", "watch"], clusterrole_extra_verbs),
    }],
  };
  local clusterrolebinding = kube.ClusterRoleBinding(rolename) {
    subjects_: [serviceaccount],
    roleRef_: clusterrole,
  };
  // Create role in destination namespace to allow managing the resource kind
  local role = if dest_ns != null then kube.Role(rolename) {
    metadata+: {
      namespace: dest_ns,
    },
    rules+: [{
      apiGroups: [objdata.apigroup],
      resources: [resource],
      verbs: verbs,
    }],
  };
  local rolebinding = if dest_ns != null then kube.RoleBinding(rolename) {
    metadata+: {
      namespace: dest_ns,
    },
    subjects_: [serviceaccount],
    roleRef_: role,
  };
  {
    serviceaccount: serviceaccount,
    objs: std.prune([
      serviceaccount,
      clusterrole,
      clusterrolebinding,
      role,
      rolebinding
    ]),
  };

local obj_data(obj) =
  local apigrp = std.split(obj.apiVersion, '/')[0];
  {
    apiVersion: obj.apiVersion,
    apigroup:: if apigrp == "v1" then "" else apigrp,
    kind: obj.kind,
    name: obj.metadata.name,
    namespace: if std.objectHas(obj.metadata, 'namespace') then obj.metadata.namespace,
  };

local rl_obj_name(objdata) =
  if objdata.namespace != null then
    "%(namespace)s-%(name)s" % objdata
  else
    objdata.name;

/**
 * \brief Create a managed resource (similar to Espejo, but for single NS)
 *
 * \arg `obj` A valid and complete Kubernetes manifest of the object to manage.
 *
 * \return A list containing a ServiceAccount, RBAC rules and the
 *         ResourceLocker object
 */
local Resource(obj) =
  local objdata = obj_data(obj);
  local rbac = rbac_objs(objdata);
  local name = rl_obj_name(objdata);
  rbac.objs + [resource(name, rbac.serviceaccount.metadata.name, obj)];

/**
 * \brief Create a resource patch which the operator will continuously apply
 *        to the target resource
 *
 * \arg `targetobj` A valid (but not necessarily complete) Kubernetes manifest
 *                  of the object to manage. The fields which are required to
 *                  be set are `apiVersion`, `kind`, `metadata.name` and
 *                  `metadata.namespace`.
 * \arg `patchtemplate` The patch to apply to `targetobj`, interpreted as a
 *                      strategic merge patch by default.
 * \arg `patchstrategy` The patch strategy to use, defaults to
 *                      `application/strategic-merge-patch+json`
 *
 * \return A list containing a ServiceAccount, RBAC rules and the
 *         ResourceLocker object
 */
local Patch(targetobj, patchtemplate, patchstrategy="application/strategic-merge-patch+json") =
  local objdata = obj_data(targetobj);
  local rbac = rbac_objs(objdata, verbs=["get", "patch"]);
  local name = rl_obj_name(objdata);
  rbac.objs + [patch(name, rbac.serviceaccount.metadata.name,
      std.prune(objdata), patchtemplate, patchstrategy)];


{
  Resource: Resource,
  Patch: Patch,
}
