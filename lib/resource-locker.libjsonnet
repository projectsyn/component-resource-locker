/**
 * \file resource-locker.libjsonnet
 * \brief methods to create resource-locker-operator resource and patch objects
 *
 * NOTE: when users override the helm chart version in the hierarchy, the
 * ResourceLocker objects generated by this library may break, cf.
 * https://github.com/projectsyn/component-resource-locker/issues/9
 */

local com = import 'lib/commodore.libjsonnet';
local kap = import 'lib/kapitan.libjsonnet';
local kube = import 'lib/kube.libjsonnet';
local inv = kap.inventory();
local resource_locker_params = inv.parameters.resource_locker;
local namespace = resource_locker_params.namespace;

local resource_locker_version =
  if std.objectHas(resource_locker_params, 'charts') then
    resource_locker_params.charts['resource-locker-operator'];

// Inject `id` for patches for resource-locker v1.x
// Defaults to v1.x logic when image version cannot be determined from
// parameters.
local render_patch(patch, rl_version, patch_id='patch1') =
  if (
    rl_version != null &&
    std.startsWith(rl_version, 'v0')
  ) then
    patch
  else
    patch {
      id: patch_id,
    };

/**
 * \brief The apiVersion to use when creating `ResourceLocker` objects without
 *        using the helper functions in this library.
 *
 * NOTE: This needs to match the version of the CRD deployed by the Helm chart.
 */
local apiVersion = 'redhatcop.redhat.io/v1alpha1';

local resourcelocker(name, sa) =
  kube._Object(apiVersion, 'ResourceLocker', name) {
    metadata+: {
      namespace: namespace,
      annotations+: {
        'argocd.argoproj.io/sync-options': 'SkipDryRunOnMissingResource=true',
      },
    },
    spec: {
      serviceAccountRef: {
        name: sa,
      },
    },
  };

// obj can be an arbitrary, valid Kubernetes object manifest
local resource(name, sa, obj) =
  resourcelocker(name, sa) {
    spec+: {
      resources: [ {
        excludedPaths: [
          '.metadata',
          '.status',
          '.spec.replicas',
        ],
        object: obj,
      } ],
    },
  };

local patch(name, sa, targetobjref, patchtemplate, patchtype='application/strategic-merge-patch+json') =
  resourcelocker(name, sa) {
    spec+: {
      patches: [ render_patch(
        {
          targetObjectRef: targetobjref,
          patchTemplate: std.manifestYamlDoc(patchtemplate),
          patchType: patchtype,
        },
        resource_locker_version
      ) ],
    },
  };

local clusterRoleName(name) =
  local prefix = namespace + '-';
  local suffix = '-manager';
  local maxLength = 63 - std.length(prefix) - std.length(suffix);
  local nameLength = std.length(name);
  local start = nameLength - std.min(maxLength, std.length(name));
  prefix + std.substr(name, start, nameLength) + suffix;

local replaceColon(str) =
  std.strReplace(str, ':', '-');

local rl_obj_name(objdata) =
  // Some objects like ClusterRoleBinding can contain colons.
  local name = replaceColon(objdata.name);
  local n =
    if objdata.namespace != null then
      '%s-%s' % [ objdata.namespace, name ]
    else
      // Reduce potential for name collisions when generating names for
      // cluster-scoped ResourceLocker configurations.
      local prefix =
        if objdata.apigroup != '' &&
           std.length(objdata.apigroup + objdata.kind + name) <= 61
        then
          '%s-%s' % [
            std.asciiLower(objdata.kind),
            std.strReplace(objdata.apigroup, '.', '-'),
          ]
        else
          std.asciiLower(objdata.kind);
      if std.length(prefix + name) > 63 then
        name
      else
        '%s-%s' % [ prefix, name ];

  assert std.length(n) <= 63;
  n;

local rbac_objs(objdata, verbs=[ 'create', 'get', 'update', 'patch' ]) =
  local dest_ns = objdata.namespace;
  // Use full rl_obj_name to avoid collisions for cluster-scoped configs
  local name = rl_obj_name(objdata);
  // Create sa if not provided
  local saname = name + '-manager';
  local serviceaccount = kube.ServiceAccount(saname) {
    metadata+: {
      namespace: namespace,
    },
  };
  // Create cluster role to get/list/watch resource kind
  local rolename = clusterRoleName(name);
  local res = std.asciiLower(objdata.kind);
  local suffix = if std.endsWith(res, 's') then 'es' else 's';
  local resource = res + suffix;
  local clusterrole_extra_verbs = if dest_ns == null then verbs else [];
  local clusterrole = kube.ClusterRole(rolename) {
    rules+: [ {
      apiGroups: [ objdata.apigroup ],
      resources: [ resource ],
      verbs: std.setUnion([ 'list', 'watch' ], clusterrole_extra_verbs),
    } ],
  };
  local clusterrolebinding = kube.ClusterRoleBinding(rolename) {
    subjects_: [ serviceaccount ],
    roleRef_: clusterrole,
  };
  // Create role in destination namespace to allow managing the resource kind
  local role = if dest_ns != null then kube.Role(rolename) {
    metadata+: {
      namespace: dest_ns,
    },
    rules+: [ {
      apiGroups: [ objdata.apigroup ],
      resources: [ resource ],
      verbs: verbs,
    } ],
  };
  local rolebinding = if dest_ns != null then kube.RoleBinding(rolename) {
    metadata+: {
      namespace: dest_ns,
    },
    subjects_: [ serviceaccount ],
    roleRef_: role,
  };
  {
    serviceaccount: serviceaccount,
    objs: std.prune([
      serviceaccount,
      clusterrole,
      clusterrolebinding,
      role,
      rolebinding,
    ]),
  };

local obj_data(obj) =
  local apigrp = std.split(obj.apiVersion, '/')[0];
  {
    apiVersion: obj.apiVersion,
    apigroup:: if apigrp == 'v1' then '' else apigrp,
    kind: obj.kind,
    name: obj.metadata.name,
    namespace: if std.objectHas(obj.metadata, 'namespace') then obj.metadata.namespace,
  };

/**
 * \brief Create a managed resource (similar to Espejo, but for single NS)
 *
 * \arg `obj` A valid and complete Kubernetes manifest of the object to manage.
 *
 * \return A list containing a ServiceAccount, RBAC rules and the
 *         ResourceLocker object
 */
local Resource(obj) =
  local objdata = obj_data(obj);
  local rbac = rbac_objs(objdata);
  local name = rl_obj_name(objdata);
  rbac.objs + [ resource(name, rbac.serviceaccount.metadata.name, obj) ];

/**
 * \brief Create a resource patch which the operator will continuously apply
 *        to the target resource
 *
 * \arg `targetobj` A valid (but not necessarily complete) Kubernetes manifest
 *                  of the object to manage. The fields which are required to
 *                  be set are `apiVersion`, `kind`, `metadata.name` and
 *                  `metadata.namespace`.
 * \arg `patchtemplate` The patch to apply to `targetobj`, interpreted as a
 *                      strategic merge patch by default.
 * \arg `patchstrategy` The patch strategy to use, defaults to
 *                      `application/strategic-merge-patch+json`
 *
 * \return A list containing a ServiceAccount, RBAC rules and the
 *         ResourceLocker object
 */
local Patch(targetobj, patchtemplate, patchstrategy='application/strategic-merge-patch+json') =
  local objdata = obj_data(targetobj);
  local rbac = rbac_objs(objdata, verbs=[ 'get', 'patch' ]);
  local name = rl_obj_name(objdata);
  rbac.objs + [ patch(name,
                      rbac.serviceaccount.metadata.name,
                      std.prune(objdata),
                      patchtemplate,
                      patchstrategy) ];


{
  apiVersion: apiVersion,
  Resource: Resource,
  Patch: Patch,
  renderPatch: render_patch,
}
